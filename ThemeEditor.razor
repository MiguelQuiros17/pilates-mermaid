@using System.Text
@using System.Text.Json
@using Aloha.Domain.Customization
@using Aloha.Domain.Services.AdminAudit
@using Aloha.Domain.Identity.AdminUsers.Activities
@using Aloha.Domain.Identity.AdminUsers
@using Aloha.Domain.Services.Theme.ColorUtilities
@using Aloha.Infrastructure
@using Microsoft.AspNetCore.Identity
@using Microsoft.Extensions.Logging
@inject IDbContextFactory<AlohaDb> dbFactory
@inject IAdminActivityService adminActivityService
@inject UserManager<AdminUser> UserManager
@inject AuthenticationStateProvider authStateProvider
@inject NavigationManager NavigationManager
@inject IWebHostEnvironment Env
@inject IConfiguration Configuration
@inject IJSRuntime JS
@inject IThemeEditorService themeEditorService
@inject ILogger<EditBootstrapFileForm> Logger
@rendermode InteractiveServer

<AuthorizeView Roles="MahaloAdmin, MasterAdmin, ContentManager, Audit">
    <div class="card">
        <div class="card-body">
            <h5 class="card-title">Theme &amp; Bootstrap</h5>
            @if (isLoading)
            {
                <div>Loading...</div>
            }
            else
            {
                <div>
                    @if (!filteredColorList.Any())
                    {
                        <div class="text-muted">No colors detected or active stylesheet could not be loaded.</div>
                    }
                    else
                    {
                        <div class="mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <h6 class="mb-0">Whitelisted Pallete</h6>
                                @if (!IsReadOnly)
                                {
                                    <div class="btn-group btn-group-sm">
                                        <button type="button" class="btn btn-outline-secondary" @onclick="DownloadColorsJson">Download Colors JSON</button>
                                        <button type="button" class="btn btn-outline-secondary" @onclick="ToggleColorsJsonEditor">
                                            @(showColorsJsonEditor ? "Hide JSON editor" : "Show JSON editor")
                                        </button>
                                    </div>
                                }
                            </div>
                            @if (!IsReadOnly && showColorsJsonEditor)
                            {
                                <textarea class="form-control form-control-sm font-monospace" rows="6" @bind="colorsJsonText"></textarea>
                                <div class="small text-muted mt-1">JSON structure: { "Colors": { "bootstrap::--bs-primary#1": "#112233", ... } }. Keys are whitelist identifiers.</div>
                                <div class="d-flex flex-column flex-sm-row gap-2 align-items-sm-center mt-2">
                                    <InputFile OnChange="OnColorsJsonFileSelected" accept=".json,application/json" class="form-control form-control-sm" />
                                    <button type="button" class="btn btn-sm btn-primary" @onclick="ConfirmImportColorsJsonAsync">Apply JSON</button>
                                </div>
                            }
                        </div>
                        
                        <div class="row g-2">
                            @foreach (var item in filteredColorList)
                            {
                                <div class="col-6 col-md-4 col-lg-3">
                                    <div class="card p-2">
                                        <div class="small text-muted mb-1">@item.DisplayTitle</div>
                                        <div class="d-flex align-items-center gap-2">
                                            <input type="color" class="form-control form-control-color" value="@item.CurrentHex"
                                                   disabled="@IsReadOnly"
                                                   @oninput="(e) => OnColorPicked(item.Source, item.Property, ((ChangeEventArgs)e).Value?.ToString() ?? item.CurrentHex, item.Occurrence, item.Selector)" />
                                            <div style="width:40px;height:24px;border:1px solid #ddd;background:@item.CurrentHex"></div>
                                            <div class="small ms-2 text-monospace">@item.OriginalToken</div>
                                        </div>
                                        <div class="mt-2 small text-muted">Property: @ThemeEditorIdentifierHelper.GetDisplayIdentifier(item.Source, item.Property, item.Occurrence)</div>
                                    </div>
                                </div>
                            }
                        </div>

                        @if (!IsReadOnly)
                        {
                            <div class="mt-3 d-flex flex-column flex-sm-row align-items-sm-center gap-2">
                                <div class="d-flex gap-2">
                                    <button class="btn btn-primary" disabled="@(isSaving || isLoading)" @onclick="ConfirmSaveColorEditsAsync">
                                        @(isSaving ? "Applying..." : "Apply color edits")
                                    </button>
                                    <button class="btn btn-outline-secondary" disabled="@(isLoading || !colorList.Any())" @onclick="ConfirmReloadActiveCssAsync">Reload Active Stylesheet</button>
                                </div>
                                @if (!string.IsNullOrWhiteSpace(colorsImportWarning))
                                {
                                    <div class="text-danger small">@colorsImportWarning</div>
                                }
                            </div>
                        }
                        
                        <div class="mb-3 mt-4 pt-2 border-top">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <span class="small text-muted" role="button" style="cursor:pointer;" @onclick="() => showSettingsPanel = !showSettingsPanel">
                                    <span class="me-1 @(showSettingsPanel ? "bi bi-chevron-up" : "bi bi-chevron-down")"></span>Whitelist &amp; Sync Settings
                                </span>
                                @if (showSettingsPanel && !IsReadOnly)
                                {
                                    <div class="btn-group btn-group-sm">
                                        <button type="button" class="btn btn-outline-secondary" @onclick="DownloadSettingsJson">Download JSON</button>
                                        <button type="button" class="btn btn-outline-secondary" @onclick="ToggleJsonEditor">
                                            @(showJsonEditor ? "Hide JSON editor" : "Show JSON editor")
                                        </button>
                                    </div>
                                }
                            </div>
                            
                            @if (showSettingsPanel && showJsonEditor && !IsReadOnly)
                            {
                                <textarea class="form-control form-control-sm font-monospace" rows="10" @bind="settingsJsonText"></textarea>
                                <div class="small text-muted mt-1">Paste JSON here to import. It should match the structure: { "Whitelist": { ... }, "Sync": { ... } }</div>
                                <div class="d-flex flex-column flex-sm-row gap-2 align-items-sm-center mt-2">
                                    <InputFile OnChange="OnSettingsJsonFileSelected" accept=".json,application/json" class="form-control form-control-sm" />
                                    <button type="button" class="btn btn-sm btn-primary" @onclick="ConfirmImportSettingsJsonAsync">Apply JSON</button>
                                </div>
                                @if (!string.IsNullOrWhiteSpace(importError))
                                {
                                    <div class="text-danger small mt-2">@importError</div>
                                }
                                @if (!string.IsNullOrWhiteSpace(saveError))
                                {
                                    <div class="text-danger small mt-2">@saveError</div>
                                }
                            }
                            
                            @if (showSettingsPanel)
                            {
                                @if (!string.IsNullOrWhiteSpace(saveError))
                                {
                                    <div class="alert alert-danger small mb-2">@saveError</div>
                                }
                                <div class="mt-3 p-3 border rounded bg-light">
                                    <div class="mb-3">
                                        <div class="d-flex justify-content-between align-items-center mb-2">
                                            <h6 class="mb-0">Whitelist</h6>
                                            @if (!IsReadOnly)
                                            {
                                                <button type="button" class="btn btn-sm btn-outline-danger" @onclick="ConfirmRestoreDefaultWhitelistAsync">Restore Defaults</button>
                                            }
                                        </div>
                                        <div class="mb-2 position-relative">
                                            <input class="form-control form-control-sm" placeholder="Search by color (#aabbcc / rgb(...)) or property identifier..."
                                                   disabled="@IsReadOnly"
                                                   value="@whitelistSearchText" @oninput="OnWhitelistSearchChanged" @onfocus="() => whitelistSearchOverlayVisible = true" @onblur="OnWhitelistBlur" />
                                            @if (whitelistSearchOverlayVisible && whitelistSearchResults.Any())
                                            {
                                                <div class="position-absolute top-100 start-0 end-0 mt-1 shadow-sm border rounded bg-white" style="max-height:260px;overflow-y:auto;z-index:1040;">
                                                    <div class="list-group">
                                                        @foreach (var res in whitelistSearchResults)
                                                        {
                                                            <button type="button" class="list-group-item list-group-item-action d-flex justify-content-between align-items-center @(res.Disabled || IsReadOnly ? "disabled bg-light text-muted" : "")"
                                                                    disabled="@(res.Disabled || IsReadOnly)" @onclick="() => AddToWhitelistFromSearchAsync(res)" @onmousedown:preventDefault>
                                                                <div>
                                                                    <div class="small text-monospace">@res.Label</div>
                                                                    <div class="small text-muted">@res.DisplayName</div>
                                                                </div>
                                                                <div class="d-flex align-items-center">
                                                                    <span class="me-2" style="width:20px;height:20px;border:1px solid #ccc;border-radius:3px;background:@res.Hex"></span>
                                                                    @if (res.Disabled && !string.IsNullOrWhiteSpace(res.DisabledReason))
                                                                    {
                                                                        <span class="badge bg-secondary">@res.DisabledReason</span>
                                                                    }
                                                                </div>
                                                            </button>
                                                        }
                                                    </div>
                                                </div>
                                            }
                                        </div>
                                        <div class="d-flex flex-wrap gap-2">
                                            @foreach (var item in whitelistItems)
                                            {
                                                var classes = "card p-2 whitelist-card";
                                                if (item.IsMissing) classes += " border-danger bg-light-subtle";
                                                <div class="@classes" style="width:260px;">
                                                    <div class="d-flex justify-content-between align-items-start">
                                                        <div class="small text-monospace text-muted">@ThemeEditorIdentifierHelper.GetDisplayIdentifier(item.Identifier)</div>
                                                        @if (!IsReadOnly)
                                                        {
                                                            <button type="button" class="btn btn-sm btn-link text-danger p-0 ms-1" title="Remove from whitelist" @onclick="() => RemoveWhitelistItemAsync(item)">&times;</button>
                                                        }
                                                    </div>
                                                    <div class="d-flex align-items-center gap-2 mt-2">
                                                        <span style="width:24px;height:24px;border:1px solid #ddd;border-radius:3px;background:@(item.CurrentHex ?? "#ffffff")"></span>
                                                        <input class="form-control form-control-sm" value="@item.DisplayName" @onchange="e => OnWhitelistDisplayNameChangedAsync(item, e)" />
                                                    </div>
                                                    @if (item.IsMissing)
                                                    {
                                                        <div class="text-danger small mt-2">Property not found! (Did you change your css file's structure?)</div>
                                                    }
                                                    <div class="mt-2 d-flex justify-content-end gap-1">
                                                        <button type="button" class="btn btn-sm btn-outline-secondary" title="Move up" @onclick="() => MoveWhitelistItemAsync(item, -1)">▲</button>
                                                        <button type="button" class="btn btn-sm btn-outline-secondary" title="Move down" @onclick="() => MoveWhitelistItemAsync(item, +1)">▼</button>
                                                    </div>
                                                </div>
                                            }
                                        </div>
                                    </div>
                                    <hr />
                                    <div>
                                        <div class="d-flex justify-content-between align-items-center mb-2">
                                            <h6 class="mb-0">Sync Settings</h6>
                                            @if (!IsReadOnly)
                                            {
                                                <button type="button" class="btn btn-sm btn-outline-danger" @onclick="ConfirmRestoreDefaultSyncAsync">Restore Defaults</button>
                                            }
                                        </div>
                                        <div class="mb-2 position-relative">
                                            <input class="form-control form-control-sm" placeholder="Search for parent colors..."
                                                   disabled="@IsReadOnly"
                                                   value="@syncParentSearchText" @oninput="OnSyncParentSearchChanged" @onfocus="() => syncParentSearchOverlayVisible = true" @onblur="OnSyncParentBlur" />
                                            @if (syncParentSearchOverlayVisible && syncParentSearchResults.Any())
                                            {
                                                <div class="position-absolute top-100 start-0 end-0 mt-1 shadow-sm border rounded bg-white" style="max-height:260px;overflow-y:auto;z-index:1040;">
                                                    <div class="list-group">
                                                        @foreach (var res in syncParentSearchResults)
                                                        {
                                                            <button type="button" class="list-group-item list-group-item-action d-flex justify-content-between align-items-center @(res.Disabled || IsReadOnly ? "disabled bg-light text-muted" : "")"
                                                                    disabled="@(res.Disabled || IsReadOnly)" @onclick="() => AddSyncParentFromSearchAsync(res)" @onmousedown:preventDefault>
                                                                <div>
                                                                    <div class="small text-monospace">@res.Label</div>
                                                                    <div class="small text-muted">@res.DisplayName</div>
                                                                </div>
                                                                <div class="d-flex align-items-center">
                                                                    <span class="me-2" style="width:20px;height:20px;border:1px solid #ccc;border-radius:3px;background:@res.Hex"></span>
                                                                    @if (res.Disabled && !string.IsNullOrWhiteSpace(res.DisabledReason))
                                                                    {
                                                                        <span class="badge bg-secondary">@res.DisabledReason</span>
                                                                    }
                                                                </div>
                                                            </button>
                                                        }
                                                    </div>
                                                </div>
                                            }
                                        </div>
                                        <div class="d-flex flex-column gap-2">
                                            @foreach (var parent in syncParents)
                                            {
                                                var parentClasses = "card p-2";
                                                if (parent.IsMissing) parentClasses += " border-danger bg-light-subtle";
                                                <div class="@parentClasses">
                                                    <div class="d-flex justify-content-between align-items-start mb-1">
                                                        <div>
                                                            <div class="small text-monospace">@ThemeEditorIdentifierHelper.GetDisplayIdentifier(parent.Identifier)</div>
                                                            <div class="d-flex align-items-center mt-1">
                                                                <span style="width:22px;height:22px;border:1px solid #ccc;border-radius:3px;background:@(parent.CurrentHex ?? "#ffffff")"></span>
                                                                <span class="small fw-semibold ms-2">@parent.DisplayName</span>
                                                            </div>
                                                            @if (parent.IsMissing)
                                                            {
                                                                <div class="text-danger small mt-1">Property not found! (Did you change your css file's structure?)</div>
                                                            }
                                                        </div>
                                                        @if (!IsReadOnly)
                                                        {
                                                            <button type="button" class="btn btn-sm btn-link text-danger p-0 ms-1" title="Remove parent" @onclick="() => RemoveSyncParentAsync(parent)">&times;</button>
                                                        }
                                                    </div>
                                                    <div class="mb-2 position-relative">
                                                        @{ syncChildSearchText.TryGetValue(parent.Identifier, out var childQ); }
                                                        <input class="form-control form-control-sm" placeholder="Search for child colors to sync..."
                                                               disabled="@IsReadOnly"
                                                               value="@childQ" @oninput="(e) => OnSyncChildSearchChanged(parent, e)" @onfocus="() => ShowSyncChildOverlay(parent)" @onblur="(e) => OnSyncChildBlur(parent, e)" />
                                                        @{ syncChildSearchResults.TryGetValue(parent.Identifier, out var childResults); childResults ??= new List<ColorSearchResultVm>(); }
                                                        @if (syncChildSearchOverlayVisible.Contains(parent.Identifier) && childResults.Any())
                                                        {
                                                            <div class="position-absolute top-100 start-0 end-0 mt-1 shadow-sm border rounded bg-white" style="max-height:260px;overflow-y:auto;z-index:1040;">
                                                                <div class="list-group">
                                                                    @foreach (var res in childResults)
                                                                    {
                                                                        <button type="button" class="list-group-item list-group-item-action d-flex justify-content-between align-items-center @(res.Disabled || IsReadOnly ? "disabled bg-light text-muted" : "")"
                                                                                disabled="@(res.Disabled || IsReadOnly)" @onclick="() => AddChildToParentFromSearchAsync(parent, res)" @onmousedown:preventDefault>
                                                                            <div>
                                                                                <div class="small text-monospace">@res.Label</div>
                                                                                <div class="small text-muted">@res.DisplayName</div>
                                                                            </div>
                                                                            <div class="d-flex align-items-center">
                                                                                <span class="me-2" style="width:20px;height:20px;border:1px solid #ccc;border-radius:3px;background:@res.Hex"></span>
                                                                                @if (res.Disabled && !string.IsNullOrWhiteSpace(res.DisabledReason))
                                                                                {
                                                                                    <span class="badge bg-secondary">@res.DisabledReason</span>
                                                                                }
                                                                            </div>
                                                                        </button>
                                                                    }
                                                                </div>
                                                            </div>
                                                        }
                                                    </div>
                                                    @if (parent.Children.Any())
                                                    {
                                                        <div class="d-flex flex-wrap gap-2">
                                                            @foreach (var child in parent.Children)
                                                            {
                                                                var childClasses = "badge bg-secondary d-flex align-items-center";
                                                                if (child.IsMissing) childClasses += " bg-danger-subtle text-dark";
                                                                <span class="@childClasses">
                                                                    <span class="me-1" style="width:14px;height:14px;border:1px solid #ccc;border-radius:2px;background:@(child.CurrentHex ?? "#ffffff")"></span>
                                                                    <span class="me-1 text-monospace">@ThemeEditorIdentifierHelper.GetDisplayIdentifier(child.Identifier)</span>
                                                                    @if (!IsReadOnly)
                                                                    {
                                                                        <button type="button" class="btn btn-sm btn-link @(child.IsMissing ? "text-dark" : "text-light") p-0 ms-1" title="Remove child" @onclick="() => RemoveSyncChildAsync(parent, child)">&times;</button>
                                                                    }
                                                                </span>
                                                            }
                                                        </div>
                                                    }
                                                </div>
                                            }
                                        </div>
                                    </div>
                                </div>
                            }
                        </div>
                    }
                </div>
            }
        </div>
    </div>

    @if (_showConfirmDialog)
    {
        <div class="modal d-block" tabindex="-1" style="background: rgba(0,0,0,0.5);">
            <div class="modal-dialog modal-lg modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">@_confirmTitle</h5>
                        <button type="button" class="btn-close" aria-label="Close" @onclick="OnConfirmNo"></button>
                    </div>
                    <div class="modal-body">
                        <div class="alert alert-warning mb-3">
                            <p class="mb-0">@((MarkupString)_confirmMessage)</p>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <Button Color="ButtonColor.Secondary" @onclick="OnConfirmNo">@_confirmNoText</Button>
                        <Button Color="ButtonColor.Primary" @onclick="OnConfirmYes">@_confirmYesText</Button>
                    </div>
                </div>
            </div>
        </div>
    }
</AuthorizeView>

@code {
    [Parameter] public bool IsReadOnly { get; set; }
    [Parameter] public EventCallback ColorsApplied { get; set; }

    private bool isLoading = true;
    private bool isSaving = false;
    private string bootstrapCssText = string.Empty;
    private string additionalCssText = string.Empty;
    private List<ColorEntry> colorList = new();
    private List<ColorEntry> filteredColorList = new();
    private AdminUser? adminUser;

    private Dictionary<string, string> whitelistDict = new(StringComparer.OrdinalIgnoreCase);
    private Dictionary<string, List<string>> syncDict = new(StringComparer.OrdinalIgnoreCase);
    private bool showSettingsPanel = false;

    private List<WhitelistItemVm> whitelistItems = new();
    private string whitelistSearchText = string.Empty;
    private List<ColorSearchResultVm> whitelistSearchResults = new();

    private List<SyncParentVm> syncParents = new();
    private string syncParentSearchText = string.Empty;
    private List<ColorSearchResultVm> syncParentSearchResults = new();

    private Dictionary<string, string> syncChildSearchText = new(StringComparer.OrdinalIgnoreCase);
    private Dictionary<string, List<ColorSearchResultVm>> syncChildSearchResults = new(StringComparer.OrdinalIgnoreCase);

    private bool whitelistSearchOverlayVisible = false;
    private bool syncParentSearchOverlayVisible = false;
    private HashSet<string> syncChildSearchOverlayVisible = new(StringComparer.OrdinalIgnoreCase);

    private bool showJsonEditor = false;
    private string settingsJsonText = string.Empty;
    private string? importError;
    private string? saveError;

    private bool showColorsJsonEditor = false;
    private string colorsJsonText = string.Empty;
    private string? colorsImportWarning;

    private bool _showConfirmDialog = false;
    private string _confirmTitle = string.Empty;
    private string _confirmMessage = string.Empty;
    private string _confirmYesText = "Yes";
    private string _confirmNoText = "Cancel";
    private PendingActionType _pendingAction = PendingActionType.None;
    protected override async Task OnInitializedAsync()
    {
        await using var db = await dbFactory.CreateDbContextAsync();
        var authUser = (await authStateProvider.GetAuthenticationStateAsync()).User;
        adminUser = await UserManager.FindByEmailAsync(authUser.Identity?.Name ?? string.Empty);

        CssColorExtractor.SetLogger(Logger);
        whitelistDict = ThemeEditorDefaults.GetDefaultWhitelist();
        syncDict = ThemeEditorDefaults.GetDefaultSync();
        await LoadWhitelistAndSyncFromDbAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;
        try
        {
            await LoadActiveStylesheetAndExtractColorsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load stylesheets during initialization");
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task LoadActiveStylesheetAndExtractColorsAsync()
    {
        try
        {
            bootstrapCssText = await themeEditorService.FetchActiveBootstrapCssAsync(Env.WebRootPath ?? string.Empty, Env.ContentRootPath ?? string.Empty);
            additionalCssText = await themeEditorService.FetchAdditionalCssAsync(Env.WebRootPath ?? string.Empty, Env.ContentRootPath ?? string.Empty);
            colorList.Clear();

            CssColorExtractor.ExtractColors(bootstrapCssText ?? string.Empty, "bootstrap", colorList);
            CssColorExtractor.ExtractColors(additionalCssText ?? string.Empty, "additional", colorList);

            ApplyServerWhitelist();
            RebuildSettingsFromDictionaries();
            RefreshWhitelistAndSyncBindings();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load active stylesheet and extract colors");
            colorList.Clear();
            filteredColorList = new List<ColorEntry>();
        }
    }

    private void ApplyServerWhitelist()
    {
        if ((whitelistDict == null || whitelistDict.Count == 0) && (whitelistItems == null || whitelistItems.Count == 0))
        {
            foreach (var e in colorList) e.DisplayTitle = e.Property;
            filteredColorList = colorList.ToList();
            return;
        }

        var whitelistOrder = new List<string>();
        if (whitelistItems != null && whitelistItems.Count > 0)
        {
            foreach (var w in whitelistItems)
            {
                if (string.IsNullOrWhiteSpace(w.Identifier)) continue;
                whitelistOrder.Add(ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(w.Identifier));
            }
        }
        else if (whitelistDict != null)
        {
            foreach (var key in whitelistDict.Keys)
            {
                if (string.IsNullOrWhiteSpace(key)) continue;
                whitelistOrder.Add(ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(key));
            }
        }

        if (whitelistOrder.Count == 0)
        {
            foreach (var e in colorList) e.DisplayTitle = e.Property;
            filteredColorList = colorList.ToList();
            return;
        }

        var filteredWithKey = new List<(ColorEntry Entry, string MatchKey)>();
        foreach (var entry in colorList)
        {
            var baseKey = $"{entry.Source}::{entry.Property}".Trim();
            var selectorKey = $"{baseKey}::{entry.Selector}".Trim();
            var occurrenceKey = $"{baseKey}#{entry.Occurrence}";
            var unqualifiedKey = entry.Property?.Trim() ?? string.Empty;

            string? title = null;
            string? matchedKey = null;

            if (!string.IsNullOrWhiteSpace(selectorKey) && whitelistDict.TryGetValue(selectorKey, out title))
                matchedKey = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(selectorKey);
            else if (!string.IsNullOrWhiteSpace(occurrenceKey) && whitelistDict.TryGetValue(occurrenceKey, out title))
                matchedKey = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(occurrenceKey);
            else if (!string.IsNullOrWhiteSpace(baseKey) && whitelistDict.TryGetValue(baseKey, out title))
                matchedKey = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(baseKey);
            else if (!string.IsNullOrEmpty(unqualifiedKey) && whitelistDict.TryGetValue(unqualifiedKey, out title))
                matchedKey = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(unqualifiedKey);

            if (matchedKey is null) continue;
            entry.DisplayTitle = string.IsNullOrWhiteSpace(title) ? entry.Property : title;
            filteredWithKey.Add((entry, matchedKey));
        }

        filteredColorList = filteredWithKey
            .Select((t, idx) => new { t.Entry, t.MatchKey, OriginalIndex = idx })
            .OrderBy(x => { var idx = whitelistOrder.IndexOf(x.MatchKey); return idx >= 0 ? idx : int.MaxValue; })
            .ThenBy(x => x.OriginalIndex)
            .Select(x => x.Entry)
            .ToList();
    }

    private void OnColorPicked(string source, string property, string newHex, int? occurrence = null, string? selector = null)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(property)) return;
            if (colorList == null) colorList = new List<ColorEntry>();

            string normalizedHex;
            try { normalizedHex = CssColorUtils.NormalizeHexForStorage(newHex); }
            catch (Exception ex) { Logger.LogWarning(ex, "Invalid hex color value: {Hex}", newHex); return; }

            var prop = property.Trim();
            List<ColorEntry> picked;

            if (occurrence.HasValue)
            {
                picked = colorList.Where(e => string.Equals(e.Source ?? string.Empty, source ?? string.Empty, StringComparison.OrdinalIgnoreCase) &&
                    e.Occurrence == occurrence.Value && string.Equals(e.Property ?? string.Empty, prop, StringComparison.OrdinalIgnoreCase)).ToList();
            }
            else if (!string.IsNullOrWhiteSpace(selector))
            {
                picked = colorList.Where(e => string.Equals(e.Source ?? string.Empty, source ?? string.Empty, StringComparison.OrdinalIgnoreCase) &&
                    string.Equals((e.Selector ?? string.Empty).Trim(), selector.Trim(), StringComparison.OrdinalIgnoreCase) &&
                    string.Equals(e.Property ?? string.Empty, prop, StringComparison.OrdinalIgnoreCase)).ToList();
            }
            else
            {
                picked = ThemeEditorIdentifierHelper.FindEntriesByIdentifier(source, prop, requireSource: true, colorList).ToList();
                if (!picked.Any()) picked = ThemeEditorIdentifierHelper.FindEntriesByIdentifier(null, prop, requireSource: false, colorList).ToList();
            }

            if (picked.Count > 1) picked = new List<ColorEntry> { picked.First() };

            if (!picked.Any())
            {
                var created = new ColorEntry
                {
                    Source = string.IsNullOrWhiteSpace(source) ? "bootstrap" : source,
                    Property = prop,
                    Selector = selector ?? "(unknown)",
                    Occurrence = occurrence ?? 1,
                    OriginalToken = normalizedHex,
                    CurrentHex = normalizedHex,
                    DisplayTitle = prop
                };
                colorList.Add(created);
                StateHasChanged();
                return;
            }

            var primary = picked.First();
            var primaryId = ThemeEditorIdentifierHelper.GetIdentifier(primary);
            var toUpdate = new List<ColorEntry> { primary };

            var sameSlot = colorList.Where(e => !ReferenceEquals(e, primary) &&
                string.Equals(e.Source ?? string.Empty, primary.Source ?? string.Empty, StringComparison.OrdinalIgnoreCase) &&
                e.Occurrence == primary.Occurrence &&
                string.Equals(e.Property ?? string.Empty, primary.Property ?? string.Empty, StringComparison.OrdinalIgnoreCase)).ToList();

            toUpdate.AddRange(sameSlot);
            toUpdate = toUpdate.Where(e => e != null).GroupBy(e => (e.Source, e.Property, e.Selector, e.Occurrence, e.OriginalToken)).Select(g => g.First()).ToList();

            foreach (var e in toUpdate)
            {
                e.IsUserEdited = true;
                e.CurrentHex = normalizedHex;
                if (CssColorParser.OriginalIsRgbTriple(e.OriginalToken))
                    e.OriginalTokenReplacement = CssColorConverter.HexToRgbTriple(normalizedHex);
                else if (CssColorParser.OriginalIsCssRgbFunction(e.OriginalToken))
                    e.OriginalTokenReplacement = CssColorConverter.HexToCssRgbFunction(normalizedHex, e.OriginalToken);
                else
                    e.OriginalTokenReplacement = null;
            }

            if (syncDict == null) { StateHasChanged(); return; }

            var syncCandidates = new[] { primaryId, $"{source}::{prop}".Trim(), prop }
                .Where(s => !string.IsNullOrWhiteSpace(s)).Distinct(StringComparer.OrdinalIgnoreCase).ToList();

            string? matchedKey = syncCandidates.FirstOrDefault(k => syncDict.ContainsKey(k));
            if (matchedKey is null) { StateHasChanged(); return; }

            var targets = syncDict[matchedKey] ?? Enumerable.Empty<string>();
            foreach (var rawTarget in targets)
            {
                if (string.IsNullOrWhiteSpace(rawTarget)) continue;
                var t = rawTarget.Trim();

                if (t.Contains("::"))
                {
                    var targetEntries = ThemeEditorIdentifierHelper.FindEntryForIdentifier(t, colorList).ToList();
                    foreach (var te in targetEntries)
                    {
                        te.IsUserEdited = true;
                        te.CurrentHex = normalizedHex;
                        if (CssColorParser.OriginalIsRgbTriple(te.OriginalToken))
                            te.OriginalTokenReplacement = CssColorConverter.HexToRgbTriple(normalizedHex);
                        else if (CssColorParser.OriginalIsCssRgbFunction(te.OriginalToken))
                            te.OriginalTokenReplacement = CssColorConverter.HexToCssRgbFunction(normalizedHex, te.OriginalToken);
                        else
                            te.OriginalTokenReplacement = null;
                    }
                }
                else
                {
                    var targetEntries = ThemeEditorIdentifierHelper.FindEntriesByIdentifier(null, t, requireSource: false, colorList)
                        .GroupBy(e => (e.Source, e.Property, e.Selector, e.Occurrence, e.OriginalToken)).Select(g => g.First()).ToList();
                    foreach (var te in targetEntries)
                    {
                        te.IsUserEdited = true;
                        te.CurrentHex = normalizedHex;
                        if (CssColorParser.OriginalIsRgbTriple(te.OriginalToken))
                            te.OriginalTokenReplacement = CssColorConverter.HexToRgbTriple(normalizedHex);
                        else if (CssColorParser.OriginalIsCssRgbFunction(te.OriginalToken))
                            te.OriginalTokenReplacement = CssColorConverter.HexToCssRgbFunction(normalizedHex, te.OriginalToken);
                        else
                            te.OriginalTokenReplacement = null;
                    }
                }
            }

            StateHasChanged();
        }
        catch (Exception ex) { Logger.LogError(ex, "Unhandled exception in OnColorPicked"); }
    }

    private async Task SaveColorEditsAsync()
    {
        isSaving = true;
        StateHasChanged();
        MarkWhitelistEntriesAsDirty();

        string finalBootstrap, finalAdditional;
        try
        {
            finalBootstrap = CssReplacementEngine.ApplyReplacementsForSource(bootstrapCssText, "bootstrap", colorList);
            finalAdditional = CssReplacementEngine.ApplyReplacementsForSource(additionalCssText, "additional", colorList);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to apply CSS replacements");
            isSaving = false;
            StateHasChanged();
            return;
        }

        try
        {
            await themeEditorService.SaveStylesheetsAsync(finalBootstrap, finalAdditional);
            await adminActivityService.TrackAdminUserActivityAsync(adminUser!, AdminActivityType.CustomTheme, "Applied color edits to bootstrap and additional stylesheets.");

            bootstrapCssText = await themeEditorService.FetchActiveBootstrapCssAsync(Env.WebRootPath ?? string.Empty, Env.ContentRootPath ?? string.Empty);
            additionalCssText = await themeEditorService.FetchAdditionalCssAsync(Env.WebRootPath ?? string.Empty, Env.ContentRootPath ?? string.Empty);
            colorList.Clear();

            CssColorExtractor.ExtractColors(bootstrapCssText, "bootstrap", colorList);
            CssColorExtractor.ExtractColors(additionalCssText, "additional", colorList);

            ApplyServerWhitelist();
            RefreshWhitelistAndSyncBindings();

            if (ColorsApplied.HasDelegate) await ColorsApplied.InvokeAsync();
            NavigationManager.NavigateTo(NavigationManager.Uri, forceLoad: false);
        }
        catch (Exception ex) { Logger.LogError(ex, "Failed to save color edits to database"); }
        finally { isSaving = false; StateHasChanged(); }
    }

    public async Task ReloadActiveCssAsync()
    {
        isLoading = true;
        StateHasChanged();
        await LoadActiveStylesheetAndExtractColorsAsync();
        isLoading = false;
        StateHasChanged();
    }

    private List<ColorSearchResultVm> BuildSearchResults(string query, bool isForWhitelist, SyncParentVm? parentContext)
    {
        var results = new List<ColorSearchResultVm>();
        if (string.IsNullOrWhiteSpace(query)) return results;

        var q = query.Trim();
        bool queryIsColor = CssColorParser.TryParseCssColorLiteral(q, out var queryHex, out _);

        var usedWhitelistIds = new HashSet<string>(whitelistItems.Select(w => w.Identifier), StringComparer.OrdinalIgnoreCase);
        var allChildIds = new HashSet<string>(syncParents.SelectMany(p => p.Children).Select(c => c.Identifier), StringComparer.OrdinalIgnoreCase);
        var parentIds = new HashSet<string>(syncParents.Select(p => p.Identifier), StringComparer.OrdinalIgnoreCase);

        foreach (var e in colorList)
        {
            var id = $"{e.Source}::{e.Property}#{e.Occurrence}";
            var label = ThemeEditorIdentifierHelper.GetDisplayIdentifier(id);

            if (results.Any(r => string.Equals(r.Identifier, id, StringComparison.OrdinalIgnoreCase))) continue;

            bool matches;
            if (queryIsColor)
            {
                matches = string.Equals(CssColorUtils.NormalizeHexForStorage(e.CurrentHex),
                    CssColorUtils.NormalizeHexForStorage(queryHex), StringComparison.OrdinalIgnoreCase);
            }
            else
            {
                matches = label.Contains(q, StringComparison.OrdinalIgnoreCase) ||
                    (e.DisplayTitle ?? string.Empty).Contains(q, StringComparison.OrdinalIgnoreCase);
            }

            if (!matches) continue;

            var res = new ColorSearchResultVm { Identifier = id, Label = label, DisplayName = e.DisplayTitle, Hex = e.CurrentHex, Disabled = false };

            if (isForWhitelist)
            {
                if (usedWhitelistIds.Contains(id)) { res.Disabled = true; res.DisabledReason = "Already in whitelist"; }
            }
            else
            {
                if (parentContext is null)
                {
                    if (allChildIds.Contains(id))
                    {
                        var parent = syncParents.First(p => p.Children.Any(c => string.Equals(c.Identifier, id, StringComparison.OrdinalIgnoreCase)));
                        res.Disabled = true;
                        res.DisabledReason = $"Already a child of {ThemeEditorIdentifierHelper.GetDisplayIdentifier(parent.Identifier)}";
                    }
                    else if (parentIds.Contains(id)) { res.Disabled = true; res.DisabledReason = "Already assigned as a parent"; }
                }
                else
                {
                    if (string.Equals(parentContext.Identifier, id, StringComparison.OrdinalIgnoreCase)) { res.Disabled = true; res.DisabledReason = "Cannot be its own child"; }
                    else if (parentIds.Contains(id)) { res.Disabled = true; res.DisabledReason = "Already assigned as a parent"; }
                    else if (allChildIds.Contains(id))
                    {
                        var parent = syncParents.First(p => p.Children.Any(c => string.Equals(c.Identifier, id, StringComparison.OrdinalIgnoreCase)));
                        res.Disabled = true;
                        res.DisabledReason = $"Already a child of {ThemeEditorIdentifierHelper.GetDisplayIdentifier(parent.Identifier)}";
                    }
                    else if (parentContext.Children.Any(c => string.Equals(c.Identifier, id, StringComparison.OrdinalIgnoreCase))) { res.Disabled = true; res.DisabledReason = "Already a child of this parent"; }
                }
            }

            results.Add(res);
        }

        return results;
    }

    private void OnWhitelistSearchChanged(ChangeEventArgs e)
    {
        whitelistSearchText = e.Value?.ToString() ?? string.Empty;
        whitelistSearchResults = BuildSearchResults(whitelistSearchText, isForWhitelist: true, parentContext: null);
    }

    private void OnSyncParentSearchChanged(ChangeEventArgs e)
    {
        syncParentSearchText = e.Value?.ToString() ?? string.Empty;
        syncParentSearchResults = BuildSearchResults(syncParentSearchText, isForWhitelist: false, parentContext: null);
    }

    private async Task AddToWhitelistFromSearchAsync(ColorSearchResultVm res)
    {
        if (res.Disabled) return;
        var id = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(res.Identifier);
        if (whitelistItems.Any(w => string.Equals(w.Identifier, id, StringComparison.OrdinalIgnoreCase))) return;

        whitelistItems.Add(new WhitelistItemVm { Identifier = id, DisplayName = res.DisplayName ?? res.Label, CurrentHex = res.Hex });
        RebuildDictionariesFromSettings();
        RefreshWhitelistAndSyncBindings();
        whitelistSearchResults.Clear();
        whitelistSearchText = string.Empty;
        whitelistSearchOverlayVisible = false;
        
        try
        {
            await SaveWhitelistAndSyncToDbAsync();
            saveError = null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save whitelist after adding item");
            saveError = "Failed to save whitelist settings.";
        }
        StateHasChanged();
    }

    private async Task RemoveWhitelistItemAsync(WhitelistItemVm item)
    {
        whitelistItems.Remove(item);
        RebuildDictionariesFromSettings();
        RefreshWhitelistAndSyncBindings();
        
        try
        {
            await SaveWhitelistAndSyncToDbAsync();
            saveError = null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save whitelist after removing item");
            saveError = "Failed to save whitelist settings.";
        }
        StateHasChanged();
    }

    private async Task MoveWhitelistItemAsync(WhitelistItemVm item, int delta)
    {
        var idx = whitelistItems.IndexOf(item);
        if (idx < 0) return;
        var newIdx = idx + delta;
        if (newIdx < 0 || newIdx >= whitelistItems.Count) return;

        whitelistItems.RemoveAt(idx);
        whitelistItems.Insert(newIdx, item);
        RebuildDictionariesFromSettings();
        RefreshWhitelistAndSyncBindings();
        
        try
        {
            await SaveWhitelistAndSyncToDbAsync();
            saveError = null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save whitelist after moving item");
            saveError = "Failed to save whitelist settings.";
        }
        StateHasChanged();
    }

    private async Task OnWhitelistDisplayNameChangedAsync(WhitelistItemVm item, ChangeEventArgs e)
    {
        item.DisplayName = e.Value?.ToString() ?? string.Empty;
        RebuildDictionariesFromSettings();
        RefreshWhitelistAndSyncBindings();
        
        try
        {
            await SaveWhitelistAndSyncToDbAsync();
            saveError = null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save whitelist after changing display name");
            saveError = "Failed to save whitelist settings.";
        }
        StateHasChanged();
    }

    private async Task AddSyncParentFromSearchAsync(ColorSearchResultVm res)
    {
        if (res.Disabled) return;
        var id = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(res.Identifier);
        if (syncParents.Any(p => string.Equals(p.Identifier, id, StringComparison.OrdinalIgnoreCase))) return;

        var allChildIds = new HashSet<string>(syncParents.SelectMany(p => p.Children).Select(c => c.Identifier), StringComparer.OrdinalIgnoreCase);
        if (allChildIds.Contains(id)) return;

        syncParents.Add(new SyncParentVm { Identifier = id, DisplayName = res.DisplayName ?? res.Label });
        RebuildDictionariesFromSettings();
        RefreshWhitelistAndSyncBindings();
        RefreshSearchResults();
        
        try
        {
            await SaveWhitelistAndSyncToDbAsync();
            saveError = null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save sync settings after adding parent");
            saveError = "Failed to save sync settings.";
        }
        StateHasChanged();
    }

    private async Task RemoveSyncParentAsync(SyncParentVm parent)
    {
        syncParents.Remove(parent);
        RebuildDictionariesFromSettings();
        RefreshWhitelistAndSyncBindings();
        RefreshSearchResults();
        
        try
        {
            await SaveWhitelistAndSyncToDbAsync();
            saveError = null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save sync settings after removing parent");
            saveError = "Failed to save sync settings.";
        }
        StateHasChanged();
    }

    private void OnSyncChildSearchChanged(SyncParentVm parent, ChangeEventArgs e)
    {
        var val = e.Value?.ToString() ?? string.Empty;
        var key = parent.Identifier;
        syncChildSearchText[key] = val;
        syncChildSearchResults[key] = BuildSearchResults(val, isForWhitelist: false, parentContext: parent);
    }

    private async Task AddChildToParentFromSearchAsync(SyncParentVm parent, ColorSearchResultVm res)
    {
        if (res.Disabled) return;
        var id = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(res.Identifier);

        var parentIds = new HashSet<string>(syncParents.Select(p => p.Identifier), StringComparer.OrdinalIgnoreCase);
        var allChildIds = new HashSet<string>(syncParents.SelectMany(p => p.Children).Select(c => c.Identifier), StringComparer.OrdinalIgnoreCase);

        if (parentIds.Contains(id) || allChildIds.Contains(id)) return;

        parent.Children.Add(new SyncChildVm { Identifier = id, DisplayName = res.DisplayName ?? res.Label, CurrentHex = res.Hex });
        RebuildDictionariesFromSettings();
        RefreshWhitelistAndSyncBindings();

        var key = parent.Identifier;
        syncChildSearchText[key] = string.Empty;
        syncChildSearchResults[key] = new List<ColorSearchResultVm>();
        HideSyncChildOverlay(parent);
        
        try
        {
            await SaveWhitelistAndSyncToDbAsync();
            saveError = null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save sync settings after adding child");
            saveError = "Failed to save sync settings.";
        }
        StateHasChanged();
    }

    private async Task RemoveSyncChildAsync(SyncParentVm parent, SyncChildVm child)
    {
        parent.Children.Remove(child);
        RebuildDictionariesFromSettings();
        RefreshWhitelistAndSyncBindings();
        RefreshSearchResults();
        
        try
        {
            await SaveWhitelistAndSyncToDbAsync();
            saveError = null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save sync settings after removing child");
            saveError = "Failed to save sync settings.";
        }
        StateHasChanged();
    }

    private void ShowSyncChildOverlay(SyncParentVm parent) => syncChildSearchOverlayVisible.Add(parent.Identifier);
    private void HideSyncChildOverlay(SyncParentVm parent) => syncChildSearchOverlayVisible.Remove(parent.Identifier);

    private void RefreshSearchResults()
    {
        syncParentSearchResults.Clear();
        syncParentSearchText = string.Empty;
        syncParentSearchOverlayVisible = false;
        syncChildSearchText.Clear();
        syncChildSearchResults.Clear();
        syncChildSearchOverlayVisible.Clear();
    }

    private void RebuildSettingsFromDictionaries()
    {
        whitelistItems = new List<WhitelistItemVm>();
        foreach (var kv in whitelistDict ?? new Dictionary<string, string>())
        {
            var idCanonical = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(kv.Key);
            whitelistItems.Add(new WhitelistItemVm { Identifier = idCanonical, DisplayName = kv.Value ?? string.Empty });
        }

        syncParents = new List<SyncParentVm>();
        foreach (var kv in syncDict ?? new Dictionary<string, List<string>>())
        {
            var parentId = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(kv.Key);
            var parentVm = new SyncParentVm { Identifier = parentId, DisplayName = ThemeEditorIdentifierHelper.GetDisplayIdentifier(parentId) };
            foreach (var childRaw in kv.Value ?? new List<string>())
            {
                var childId = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(childRaw);
                parentVm.Children.Add(new SyncChildVm { Identifier = childId, DisplayName = ThemeEditorIdentifierHelper.GetDisplayIdentifier(childId) });
            }
            syncParents.Add(parentVm);
        }
    }

    private void RefreshWhitelistAndSyncBindings()
    {
        foreach (var item in whitelistItems)
        {
            var entry = ThemeEditorIdentifierHelper.FindEntryForIdentifier(item.Identifier, colorList).FirstOrDefault();
            if (entry is null)
            {
                item.CurrentHex = "#ffffff";
                item.IsMissing = true;
                item.MissingMessage = "Property not found! (Did you change your css file's structure?)";
            }
            else
            {
                item.CurrentHex = entry.CurrentHex;
                item.IsMissing = false;
                item.MissingMessage = null;
            }
            if (string.IsNullOrWhiteSpace(item.DisplayName))
                item.DisplayName = ThemeEditorIdentifierHelper.GetDisplayIdentifier(item.Identifier);
        }

        var allChildIds = new HashSet<string>(syncParents.SelectMany(p => p.Children).Select(c => c.Identifier), StringComparer.OrdinalIgnoreCase);
        foreach (var parent in syncParents)
        {
            var pEntry = ThemeEditorIdentifierHelper.FindEntryForIdentifier(parent.Identifier, colorList).FirstOrDefault();
            if (pEntry is null)
            {
                parent.CurrentHex = "#ffffff";
                parent.IsMissing = true;
                parent.MissingMessage = "Property not found! (Did you change your css file's structure?)";
            }
            else
            {
                parent.CurrentHex = pEntry.CurrentHex;
                parent.IsMissing = false;
                parent.MissingMessage = null;
            }
            if (string.IsNullOrWhiteSpace(parent.DisplayName))
                parent.DisplayName = ThemeEditorIdentifierHelper.GetDisplayIdentifier(parent.Identifier);

            foreach (var child in parent.Children)
            {
                var cEntry = ThemeEditorIdentifierHelper.FindEntryForIdentifier(child.Identifier, colorList).FirstOrDefault();
                if (cEntry is null)
                {
                    child.CurrentHex = "#ffffff";
                    child.IsMissing = true;
                    child.MissingMessage = "Property not found! (Did you change your css file's structure?)";
                }
                else
                {
                    child.CurrentHex = cEntry.CurrentHex;
                    child.IsMissing = false;
                    child.MissingMessage = null;
                }
                if (string.IsNullOrWhiteSpace(child.DisplayName))
                    child.DisplayName = ThemeEditorIdentifierHelper.GetDisplayIdentifier(child.Identifier);
            }
        }
        StateHasChanged();
    }

    private async Task LoadWhitelistAndSyncFromDbAsync()
    {
        var dto = await themeEditorService.LoadSettingsFromDbAsync();
        if (dto?.Whitelist is not null)
            whitelistDict = new Dictionary<string, string>(dto.Whitelist, StringComparer.OrdinalIgnoreCase);
        if (dto?.Sync is not null)
            syncDict = new Dictionary<string, List<string>>(dto.Sync, StringComparer.OrdinalIgnoreCase);
    }

    private async Task SaveWhitelistAndSyncToDbAsync()
    {
        var dto = BuildCurrentSettingsDto();
        await themeEditorService.SaveSettingsToDbAsync(dto);
    }

    private ThemeEditorColorsDto BuildCurrentColorsDto()
    {
        var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        foreach (var item in whitelistItems)
        {
            if (string.IsNullOrWhiteSpace(item.Identifier)) continue;
            var id = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(item.Identifier);
            var entry = ThemeEditorIdentifierHelper.FindEntryForIdentifier(id, colorList).FirstOrDefault();
            if (entry is null) continue;
            try { dict[id] = CssColorUtils.NormalizeHexForStorage(entry.CurrentHex); }
            catch (Exception ex) { Logger.LogWarning(ex, "Invalid hex color for identifier {Identifier}: {Hex}", id, entry.CurrentHex); }
        }
        return new ThemeEditorColorsDto { Colors = dict };
    }

    private ThemeEditorSettingsDto BuildCurrentSettingsDto()
    {
        var wlCopy = new Dictionary<string, string>(whitelistDict ?? new Dictionary<string, string>(), StringComparer.OrdinalIgnoreCase);
        var syncCopy = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
        foreach (var kv in syncDict ?? new Dictionary<string, List<string>>())
            syncCopy[kv.Key] = new List<string>(kv.Value ?? new List<string>());
        return new ThemeEditorSettingsDto { Whitelist = wlCopy, Sync = syncCopy };
    }

    private async Task DownloadSettingsJson()
    {
        try
        {
            RebuildDictionariesFromSettings();
            var dto = BuildCurrentSettingsDto();
            var json = JsonSerializer.Serialize(dto, new JsonSerializerOptions { WriteIndented = true });
            settingsJsonText = json;
            importError = null;
            await JS.InvokeVoidAsync("downloadFile", "theme-editor-settings.json", "application/json", "utf-8", json);
        }
        catch (Exception ex) { Logger.LogError(ex, "Failed to download settings JSON"); importError = "Failed to generate JSON for download."; }
    }

    private async Task DownloadColorsJson()
    {
        try
        {
            var dto = BuildCurrentColorsDto();
            var json = JsonSerializer.Serialize(dto, new JsonSerializerOptions { WriteIndented = true });
            colorsJsonText = json;
            colorsImportWarning = null;
            await JS.InvokeVoidAsync("downloadFile", "theme-editor-colors.json", "application/json", "utf-8", json);
        }
        catch (Exception ex) { Logger.LogError(ex, "Failed to download colors JSON"); colorsImportWarning = "Failed to generate colors JSON."; }
    }

    private void ToggleColorsJsonEditor()
    {
        if (!showColorsJsonEditor)
        {
            try
            {
                var dto = BuildCurrentColorsDto();
                colorsJsonText = JsonSerializer.Serialize(dto, new JsonSerializerOptions { WriteIndented = true });
                colorsImportWarning = null;
            }
            catch (Exception ex) { Logger.LogError(ex, "Failed to build colors JSON snapshot"); colorsImportWarning = "Failed to build current colors JSON snapshot."; }
        }
        showColorsJsonEditor = !showColorsJsonEditor;
    }

    private void ToggleJsonEditor()
    {
        if (!showJsonEditor)
        {
            try
            {
                RebuildDictionariesFromSettings();
                var dto = BuildCurrentSettingsDto();
                settingsJsonText = JsonSerializer.Serialize(dto, new JsonSerializerOptions { WriteIndented = true });
                importError = null;
            }
            catch (Exception ex) { Logger.LogError(ex, "Failed to build settings JSON snapshot"); importError = "Failed to build current JSON snapshot."; }
        }
        showJsonEditor = !showJsonEditor;
    }

    private void ImportColorsJson()
    {
        colorsImportWarning = null;
        if (string.IsNullOrWhiteSpace(colorsJsonText)) { colorsImportWarning = "Color JSON is empty."; return; }

        ThemeEditorColorsDto? dto;
        try { dto = JsonSerializer.Deserialize<ThemeEditorColorsDto>(colorsJsonText); }
        catch (Exception ex) { Logger.LogError(ex, "Failed to parse colors JSON"); colorsImportWarning = "Could not parse color JSON. Make sure it matches the expected structure."; return; }

        if (dto?.Colors is null || dto.Colors.Count == 0) { colorsImportWarning = "No color values found in JSON."; return; }

        var whitelistKeys = new HashSet<string>(whitelistItems.Where(w => !string.IsNullOrWhiteSpace(w.Identifier))
            .Select(w => ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(w.Identifier)), StringComparer.OrdinalIgnoreCase);
        var importedKeys = new HashSet<string>(dto.Colors.Keys.Where(k => !string.IsNullOrWhiteSpace(k))
            .Select(ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage), StringComparer.OrdinalIgnoreCase);
        var extraKeys = importedKeys.Where(k => !whitelistKeys.Contains(k)).ToList();
        var missingKeys = whitelistKeys.Where(k => !importedKeys.Contains(k)).ToList();
        var handledParents = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        foreach (var kv in dto.Colors)
        {
            if (string.IsNullOrWhiteSpace(kv.Key)) continue;
            var key = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(kv.Key);
            if (!whitelistKeys.Contains(key) || !handledParents.Add(key)) continue;

            var primary = ThemeEditorIdentifierHelper.FindEntryForIdentifier(key, colorList).FirstOrDefault();
            if (primary is null) continue;

            try { OnColorPicked(primary.Source, primary.Property, kv.Value, primary.Occurrence, primary.Selector); }
            catch (Exception ex) { Logger.LogWarning(ex, "Failed to apply color for identifier {Identifier}", key); }
        }

        RefreshWhitelistAndSyncBindings();
        ApplyServerWhitelist();

        if (extraKeys.Any()) colorsImportWarning = "Some properties imported aren't present in your whitelist! (Have you imported your whitelist yet?)";
        else if (missingKeys.Any()) colorsImportWarning = "The properties imported don't fill your whole whitelist! (Have you imported your whitelist yet?)";
        else colorsImportWarning = null;

        StateHasChanged();
    }

    private async Task ImportSettingsJson()
    {
        importError = null;
        if (string.IsNullOrWhiteSpace(settingsJsonText)) { importError = "JSON is empty."; return; }

        try
        {
            ThemeEditorSettingsDto? dto = null;
            try { dto = JsonSerializer.Deserialize<ThemeEditorSettingsDto>(settingsJsonText); }
            catch (Exception ex) { Logger.LogError(ex, "Failed to parse settings JSON"); importError = "Could not parse JSON. Make sure it matches the expected structure."; return; }

            if (dto is null) { importError = "Deserialized JSON is null."; return; }

            whitelistDict = dto.Whitelist != null ? new Dictionary<string, string>(dto.Whitelist, StringComparer.OrdinalIgnoreCase) : new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            syncDict = dto.Sync != null ? new Dictionary<string, List<string>>(dto.Sync, StringComparer.OrdinalIgnoreCase) : new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);

            RebuildSettingsFromDictionaries();
            ApplyServerWhitelist();
            RefreshWhitelistAndSyncBindings();
            RefreshSearchResults();
            await SaveWhitelistAndSyncToDbAsync();
            importError = null;
            saveError = null;
            StateHasChanged();
        }
        catch (Exception ex) { Logger.LogError(ex, "Failed to import settings JSON"); importError = "Failed to import JSON."; }
    }

    private async Task RestoreDefaultWhitelistAsync()
    {
        try
        {
            whitelistDict = ThemeEditorDefaults.GetDefaultWhitelistExtended();
            RebuildSettingsFromDictionaries();
            RefreshWhitelistAndSyncBindings();
            RefreshSearchResults();
            RefreshWhitelistDisplayNames();
            await SaveWhitelistAndSyncToDbAsync();
            saveError = null;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to restore default whitelist");
            saveError = "Failed to save whitelist settings.";
            StateHasChanged();
        }
    }

    private async Task RestoreDefaultSyncAsync()
    {
        try
        {
            syncDict = ThemeEditorDefaults.GetDefaultSyncExtended();
            RebuildSettingsFromDictionaries();
            RefreshWhitelistAndSyncBindings();
            RefreshSearchResults();
            RefreshWhitelistDisplayNames();
            await SaveWhitelistAndSyncToDbAsync();
            saveError = null;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to restore default sync settings");
            saveError = "Failed to save sync settings.";
            StateHasChanged();
        }
    }

    private void RefreshWhitelistDisplayNames()
    {
        if (whitelistItems == null) return;
        var newWhitelist = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        foreach (var item in whitelistItems)
        {
            if (string.IsNullOrWhiteSpace(item.Identifier)) continue;
            var key = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(item.Identifier);
            var value = string.IsNullOrWhiteSpace(item.DisplayName) ? ThemeEditorIdentifierHelper.GetDisplayIdentifier(item.Identifier) : item.DisplayName.Trim();
            newWhitelist[key] = value;
        }
        whitelistDict = newWhitelist;
        ApplyServerWhitelist();
        RefreshWhitelistAndSyncBindings();
        StateHasChanged();
    }

    private void RebuildDictionariesFromSettings()
    {
        var newWhitelist = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        foreach (var item in whitelistItems)
        {
            if (string.IsNullOrWhiteSpace(item.Identifier)) continue;
            var key = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(item.Identifier);
            var value = string.IsNullOrWhiteSpace(item.DisplayName) ? ThemeEditorIdentifierHelper.GetDisplayIdentifier(item.Identifier) : item.DisplayName.Trim();
            newWhitelist[key] = value;
        }
        whitelistDict = newWhitelist;

        var newSync = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
        foreach (var parent in syncParents)
        {
            if (string.IsNullOrWhiteSpace(parent.Identifier)) continue;
            var pKey = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(parent.Identifier);
            if (!newSync.TryGetValue(pKey, out var list)) { list = new List<string>(); newSync[pKey] = list; }
            foreach (var child in parent.Children)
            {
                if (string.IsNullOrWhiteSpace(child.Identifier)) continue;
                var cKey = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(child.Identifier);
                if (!list.Contains(cKey, StringComparer.OrdinalIgnoreCase)) list.Add(cKey);
            }
        }
        syncDict = newSync;
        ApplyServerWhitelist();
    }

    private void MarkWhitelistEntriesAsDirty()
    {
        if (whitelistItems == null || whitelistItems.Count == 0) return;
        foreach (var item in whitelistItems)
        {
            if (string.IsNullOrWhiteSpace(item.Identifier)) continue;
            var id = ThemeEditorIdentifierHelper.CanonicalizeIdentifierForStorage(item.Identifier);
            var primary = ThemeEditorIdentifierHelper.FindEntryForIdentifier(id, colorList).FirstOrDefault();
            if (primary is null) continue;
            try { OnColorPicked(primary.Source, primary.Property, primary.CurrentHex, primary.Occurrence, primary.Selector); }
            catch (Exception ex) { Logger.LogWarning(ex, "Failed to re-sync whitelist entry {Identifier}", id); }
        }
    }

    private async Task OnWhitelistBlur(FocusEventArgs _)
    {
        await Task.Delay(150);
        if (!whitelistSearchOverlayVisible) return;
        whitelistSearchOverlayVisible = false;
        StateHasChanged();
    }

    private async Task OnSyncParentBlur(FocusEventArgs _)
    {
        await Task.Delay(150);
        if (!syncParentSearchOverlayVisible) return;
        syncParentSearchOverlayVisible = false;
        StateHasChanged();
    }

    private async Task OnSyncChildBlur(SyncParentVm parent, FocusEventArgs _)
    {
        await Task.Delay(150);
        if (!syncChildSearchOverlayVisible.Contains(parent.Identifier)) return;
        HideSyncChildOverlay(parent);
        StateHasChanged();
    }

    private async Task OnSettingsJsonFileSelected(InputFileChangeEventArgs e)
    {
        importError = null;
        var file = e.File;
        if (file is null) { importError = "No file selected."; return; }
        try
        {
            using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024);
            using var reader = new StreamReader(stream);
            settingsJsonText = await reader.ReadToEndAsync() ?? string.Empty;
        }
        catch (Exception ex) { Logger.LogError(ex, "Failed to read settings JSON file"); importError = "Failed to read JSON file."; }
    }

    private async Task OnColorsJsonFileSelected(InputFileChangeEventArgs e)
    {
        colorsImportWarning = null;
        var file = e.File;
        if (file is null) { colorsImportWarning = "No file selected."; return; }
        try
        {
            using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024);
            using var reader = new StreamReader(stream);
            colorsJsonText = await reader.ReadToEndAsync() ?? string.Empty;
        }
        catch (Exception ex) { Logger.LogError(ex, "Failed to read colors JSON file"); colorsImportWarning = "Failed to read colors JSON file."; }
    }

    private Task ShowConfirmAsync(PendingActionType action, string title, string message, string yesText, string noText = "Cancel")
    {
        _pendingAction = action;
        _confirmTitle = title;
        _confirmMessage = message;
        _confirmYesText = yesText;
        _confirmNoText = noText;
        _showConfirmDialog = true;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private Task ConfirmSaveColorEditsAsync() => ShowConfirmAsync(
        PendingActionType.SaveColors,
        "Apply Color Changes",
        "This action will permanently modify your theme stylesheets.<br/><br/><strong>This is an IRREVERSIBLE operation</strong> that will overwrite your current stylesheet files.<br/><br/>It is <strong>STRONGLY RECOMMENDED</strong> that you create a backup of your current stylesheets before proceeding (Advanced Settings > Download Bootstrap CSS + Download Additional CSS).<br/><br/>Are you sure you want to apply these color changes? <strong>Changes will go live IMMEDIATELY.</strong>",
        "Yes, Apply Changes");

    private Task ConfirmReloadActiveCssAsync() => ShowConfirmAsync(
        PendingActionType.ReloadCss,
        "Reload Active Stylesheet",
        "This action will reload the active stylesheet from the database, which may cause you to lose any unsaved color edits you have made.<br/><br/><strong>This action cannot be undone.</strong><br/><br/>Are you sure you want to reload the stylesheet?",
        "Yes, Reload");

    private Task ConfirmRestoreDefaultWhitelistAsync() => ShowConfirmAsync(
        PendingActionType.RestoreWhitelistDefaults,
        "Restore Whitelist Defaults",
        "This action will permanently restore the default whitelist settings, replacing your current custom whitelist configuration.<br/><br/><strong>This is an IRREVERSIBLE operation.</strong><br/><br/>It is <strong>STRONGLY RECOMMENDED</strong> that you create a backup of your current whitelist settings before proceeding (Select Download JSON at the top of the Whitelist & Sync Settings Section).<br/><br/>Are you sure you want to restore the default whitelist?",
        "Yes, Restore Defaults");

    private Task ConfirmRestoreDefaultSyncAsync() => ShowConfirmAsync(
        PendingActionType.RestoreSyncDefaults,
        "Restore Sync Defaults",
        "This action will permanently restore the default sync settings, replacing your current custom sync configuration.<br/><br/><strong>This is an IRREVERSIBLE operation.</strong><br/><br/>It is <strong>STRONGLY RECOMMENDED</strong> that you create a backup of your current sync settings before proceeding (Select Download JSON at the top of the Whitelist & Sync Settings Section).<br/><br/>Are you sure you want to restore the default sync settings?",
        "Yes, Restore Defaults");

    private Task ConfirmImportSettingsJsonAsync() => ShowConfirmAsync(
        PendingActionType.ImportSettingsJson,
        "Import Whitelist/Sync JSON",
        "This action will permanently overwrite your current whitelist and sync settings with the imported JSON configuration.<br/><br/><strong>This is an IRREVERSIBLE operation</strong> that will replace all your existing settings.<br/><br/>It is <strong>STRONGLY RECOMMENDED</strong> that you create a backup of your current settings before proceeding (Select Download JSON at the top of the Whitelist & Sync Settings Section).<br/><br/>Are you sure you want to import and apply this JSON configuration?",
        "Yes, Import & Apply");

    private Task ConfirmImportColorsJsonAsync() => ShowConfirmAsync(
        PendingActionType.ImportColorsJson,
        "Import Colors JSON",
        "This action will overwrite any unsaved color edits you have made.<br/><br/>You must still click <strong>Apply Color Edits</strong> for the uploaded JSON Colors to apply any changes to the site.<br/><br/>Are you sure you want to import this Colors JSON?",
        "Yes, Import & Apply");

    private async Task OnConfirmYes()
    {
        var action = _pendingAction;
        _pendingAction = PendingActionType.None;
        _showConfirmDialog = false;
        StateHasChanged();

        switch (action)
        {
            case PendingActionType.SaveColors: await SaveColorEditsAsync(); break;
            case PendingActionType.ReloadCss: await ReloadActiveCssAsync(); break;
            case PendingActionType.RestoreWhitelistDefaults: await RestoreDefaultWhitelistAsync(); break;
            case PendingActionType.RestoreSyncDefaults: await RestoreDefaultSyncAsync(); break;
            case PendingActionType.ImportSettingsJson: await ImportSettingsJson(); break;
            case PendingActionType.ImportColorsJson: ImportColorsJson(); break;
        }
    }

    private Task OnConfirmNo()
    {
        _pendingAction = PendingActionType.None;
        _showConfirmDialog = false;
        StateHasChanged();
        return Task.CompletedTask;
    }
}