/**
 * Utility function to construct API URLs correctly
 * Handles cases where API_BASE_URL might already include /api
 * Works in both development (Next.js rewrites) and production (Express serves both)
 */

export const getApiUrl = (path: string): string => {
  const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || ''
  
  // Si la path ya es una URL completa, retornarla
  if (path.startsWith('http://') || path.startsWith('https://')) {
    return path
  }
  
  // En desarrollo, siempre usar URL relativa para que Next.js rewrites funcionen
  // En producción, si API_BASE_URL está vacío, usar URL relativa (Express maneja /api/*)
  const isDevelopment = typeof window !== 'undefined' && 
    (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
  
  if (isDevelopment || !API_BASE_URL || API_BASE_URL.trim() === '') {
    // URL relativa - Next.js rewrite en dev, Express en prod
    return path.startsWith('/') ? path : `/${path}`
  }
  
  // Normalizar la path
  const normalizedPath = path.startsWith('/') ? path : `/${path}`
  let baseUrl = API_BASE_URL.replace(/\/$/, '')
  
  // Si el baseUrl ya termina con /api y la path empieza con /api, remover /api de la path
  if (baseUrl.endsWith('/api') && normalizedPath.startsWith('/api')) {
    return `${baseUrl}${normalizedPath.substring(4)}`
  }
  
  return `${baseUrl}${normalizedPath}`
}

/**
 * Helper function to check if a token is expired (for old tokens that had expiration)
 */
export const isTokenExpired = (token: string | null): boolean => {
  if (!token) return true
  
  try {
    // Decode token without verification to check expiration
    const base64Url = token.split('.')[1]
    if (!base64Url) return true
    
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/')
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    )
    
    const decoded = JSON.parse(jsonPayload)
    
    // If token has expiration (exp) and it's in the past, it's expired
    if (decoded.exp) {
      const expirationTime = decoded.exp * 1000 // Convert to milliseconds
      const currentTime = Date.now()
      return currentTime >= expirationTime
    }
    
    // If no expiration, token is valid (new tokens don't expire)
    return false
  } catch (error) {
    console.error('Error checking token expiration:', error)
    return true // If we can't parse it, consider it expired/invalid
  }
}

/**
 * Helper function to handle API calls with automatic token refresh and error handling
 * If a 401 error occurs (token expired), it will redirect to login
 */
export const fetchWithAuth = async (
  url: string,
  options: RequestInit = {}
): Promise<Response> => {
  const token = localStorage.getItem('token')
  
  // Don't block expired tokens - let the backend regenerate them
  // The backend will automatically regenerate expired tokens and return a new one
  // Only block if there's no token at all
  if (!token) {
    if (typeof window !== 'undefined' && !window.location.pathname.includes('/login')) {
      window.location.href = '/login'
    }
    throw new Error('No token found. Please log in.')
  }
  
  const headers = {
    ...options.headers,
    'Authorization': token ? `Bearer ${token}` : '',
    'Content-Type': 'application/json',
  }

  const response = await fetch(getApiUrl(url), {
    ...options,
    headers,
  })

  // If token expired (401), check if it's truly invalid or just expired
  // Expired tokens should be regenerated by the backend, so 401 here means invalid
  if (response.status === 401) {
    const errorData = await response.json().catch(() => ({}))
    
    // Only redirect if the token is truly invalid (not just expired)
    // The backend should regenerate expired tokens automatically
    if (errorData.message && errorData.message.includes('inválido') && !errorData.message.includes('expirado')) {
      console.error('Token is invalid (not just expired):', errorData.message)
      localStorage.removeItem('token')
      localStorage.removeItem('user')
      
      if (typeof window !== 'undefined' && !window.location.pathname.includes('/login')) {
        window.location.href = '/login'
      }
      
      throw new Error(errorData.message || 'Token invalid. Please log in again.')
    }
    
    // If it's an expired token, the backend should have regenerated it
    // This shouldn't happen, but log it for debugging
    console.warn('Received 401 but message suggests token might be expired:', errorData.message)
  }

  return response
}
